(defun C:BESTLINE (/ D1 D2 ENT ENTLIST FLAG ORTHOMODE OSMODE P P1 P2 P3 PLIST PLISTTMP)
 (setq OSMODE (getvar "OSMODE"))
 (setvar "OSMODE" 0)
 (setq ORTHOMODE (getvar "ORTHOMODE"))
 (setvar "ORTHOMODE" 0)
 (setq PLIST nil)
 (setq ENT (car (entsel "\nSelect polyline to fit line : ")))
 (setq ENTLIST (entget ENT))
 (if (= "LWPOLYLINE" (cdr (assoc 0 ENTLIST)))
  (while (/= nil ENTLIST)
   (if (= 10 (caar ENTLIST))
    (setq PLIST (append PLIST (list (cdar ENTLIST))))
   )
   (setq ENTLIST (cdr ENTLIST))
  )
  (if (= "POLYLINE" (cdr (assoc 0 ENTLIST)))
   (progn
    (setq ENT (entnext ENT))
    (setq ENTLIST (entget ENT))
    (while (= "VERTEX" (cdr (assoc 0 ENTLIST)))
     (setq P (cdr (assoc 10 ENTLIST)))
     (setq PLIST (append PLIST (list (list (car P) (cadr P)))))
     (setq ENT (entnext ENT))
     (setq ENTLIST (entget ENT))
    )
   )
   (princ "\n*** Not a polyline!")
  )
 )
 (if (/= nil (setq P1 (getpoint "\nPick a point near to start point (<return> for entire polyline) : ")))
  (if (/= nil (setq P2 (getpoint "\nPick a point near to end point : ")))
   (progn
    (setq PLISTTMP nil)
    (setq FLAG nil)
    (setq D1 (apply 'min (mapcar '(lambda (P3) (distance P1 P3)) PLIST)))
    (setq D2 (apply 'min (mapcar '(lambda (P3) (distance P2 P3)) PLIST)))
    (foreach P3 PLIST
     (progn
      (if (or (= D1 (distance P1 P3)) (= D2 (distance P2 P3)))
       (setq FLAG (not FLAG))
      )
      (if FLAG (setq PLISTTMP (append PLISTTMP (list P3))))
     )
    )
    (setq PLIST PLISTTMP)
   )
  )
 )
 (if (/= nil (setq P (BESTLINE PLIST)))
  (progn
   (setq P1 (car P))
   (setq P2 (cadr P))
   (command "._LINE" P1 P2 "")
  )
 )
 (setvar "OSMODE" OSMODE)
 (setvar "ORTHOMODE" ORTHOMODE)
 (last P)
)
(defun BESTLINE (PLIST / CALCE CALCSUME2 CALCXY COUNT OS P0 P1 P2 STEP SUME2 SUME2T1 SUME2T2 SUME2T3 SUME2T4 THETA TOL)
 (setq TOL 0.00001)
 (defun CALCXY (P P1 THETA / X Y)
  (setq X (+ (* (- (cadr P) (cadr P1)) (sin THETA)) (* (- (car P) (car P1)) (cos THETA))))
  (setq Y (- (* (- (cadr P) (cadr P1)) (cos THETA)) (* (- (car P) (car P1)) (sin THETA))))
  (list X Y)
 )
 (defun CALCE (OS THETA PLIST / NODE P YMAX)
  (setq YMAX nil)
  (setq P0 (car PLIST))
  (setq P1 (list (- (car P0) (* OS (sin THETA))) (+ (cadr P0) (* OS (cos THETA)))))
  (foreach NODE PLIST
   (setq P (CALCXY NODE P1 THETA))
   (if (= nil YMAX)
    (setq YMAX (abs (cadr P)))
    (if (> (abs (cadr P)) YMAX)
     (setq YMAX (abs (cadr P)))
    )
   )
  )
  (eval YMAX)
 )
 (defun CALCSUME2 (OS THETA PLIST / NODE P P0 P1 SUME2)
  (setq SUME2 0.0)
  (setq P0 (car PLIST))
  (setq P1 (list (- (car P0) (* OS (sin THETA))) (+ (cadr P0) (* OS (cos THETA)))))
  (foreach NODE PLIST
   (setq P (CALCXY NODE P1 THETA))
   (setq SUME2 (+ SUME2 (expt (abs (cadr P)) 2)))
  )
  (eval SUME2)
 )
 
 (setq COUNT 0)
 (setq OS 0.0)
 (setq THETA (angle (car PLIST) (last PLIST)))
 (setq STEP (CALCE OS THETA PLIST))
 (setq SUME2 (CALCSUME2 OS THETA PLIST))
 (while (> STEP TOL)
  (setq SUME2T1 (CALCSUME2 (+ OS STEP) THETA PLIST))
  (setq SUME2T2 (CALCSUME2 (- OS STEP) THETA PLIST))
  (setq SUME2T3 (CALCSUME2 OS (+ THETA (/ STEP 10.0)) PLIST))
  (setq SUME2T4 (CALCSUME2 OS (- THETA (/ STEP 10.0)) PLIST))
  (setq SUME2 (min SUME2 SUME2T1 SUME2T2 SUME2T3 SUME2T4))
  (cond ((= SUME2 SUME2T1) (setq OS (+ OS STEP)))
        ((= SUME2 SUME2T2) (setq OS (- OS STEP)))
        ((= SUME2 SUME2T3) (setq THETA (+ THETA (/ STEP 10.0))))
        ((= SUME2 SUME2T4) (setq THETA (- THETA (/ STEP 10.0))))
        (T (setq STEP (/ STEP 2.0)))
  )
  (setq COUNT (+ COUNT 1))(if (= 10000 COUNT) (exit))
 )
 (setq P0 (car PLIST))
 (setq P1 (list (- (car P0) (* OS (sin THETA))) (+ (cadr P0) (* OS (cos THETA)))))
 (setq P0 (CALCXY (last PLIST) P1 THETA))
 (setq P2 (list (+ (car P1) (* (car P0) (cos THETA)))
                (+ (cadr P1) (* (car P0) (sin THETA)))
          )
 )
 (list P1 P2 (CALCE OS THETA PLIST))
)
