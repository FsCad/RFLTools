;
;
;     Program written by Robert Livingston, 2016-09-07
;
;     C:BESTCORNER builds an alignment (Spi-Curve-Spi) based on two tangents to fit a selected polyline
;
;
(setq RFL:BESTCORNERLSMIN 0.0)
(setq RFL:BESTCORNERLSMAX 0.0)
(setq RFL:BESTCORNERR 100.0)
(setq RFL:BESTCORNERSTEP 10.0)
(setq RFL:BESTCORNERSTEPMIN 1.0)
(defun C:BESTCORNER (/ AL1 AL2 AL3 AL4 AL5 AL6
                       CALCE CALCSUME2 CONTINUEFLAG ENT ENTLIST MAKEALIGNLIST LS1 LS2
                       P P0 P1 P11 P12 P2 P21 P22 PLIST STEP STEPMIN
                       SUME2 SUME2PREV SUME2MIN SUME21 SUME22 SUME23 SUME24 SUME25 SUME26 R TMP)
 (defun CALCSUME2 (RFL:ALIGNLIST PLIST / P S SUME2)
  (setq SUME2 nil)
  (if RFL:ALIGNLIST
   (foreach P PLIST
    (if (setq S (RFL:STAOFF P))
     (if SUME2
      (setq SUME2 (+ SUME2 (expt (cadr S) 2)))
      (setq SUME2 (expt (cadr S) 2))
     )
    )
   )
  )
  SUME2
 )
 (defun CALCE (RFL:ALIGNLIST PLIST / P S E)
  (setq E 0.0)
  (if RFL:ALIGNLIST
   (foreach P PLIST
    (if (setq S (RFL:STAOFF P))
     (setq E (max E (abs (cadr S))))
    )
   )
  )
  E
 )
 (defun MAKEALIGNLIST (P1 P0 P2 LS1 R LS2 / RFL:ALIGNLIST A1 A2 ANG ANG0 ANG1 ANG2 D1 D2 DIR 
                                            PA PB PC PD PLT PLTST1 PLTST2 PST
                                            S X X0 X1 X2 X3 Y Y0 Y1 Y2 Y3)
  (setq P1 (list (car P1) (cadr P1)))
  (setq P0 (list (car P0) (cadr P0)))
  (setq P2 (list (car P2) (cadr P2)))
  (if (> (sin (- (angle P0 P2) (angle P1 P0))) 0.0)
   (setq DIR 1.0)
   (setq DIR -1.0)
  )
  (setq ANG (- pi (RFL:ANGLE3P P1 P0 P2)))
  (setq D1 (distance P1 P0))
  (setq A1 (angle P1 P0))
  (setq D2 (distance P0 P2))
  (setq A2 (angle P0 P2))
  (setq S 0.0)
  (setq ANG1 (/ LS1 (* 2.0 R)))
  (setq ANG2 (/ LS2 (* 2.0 R)))
  (setq ANG0 (- ANG ANG1 ANG2))
  (if (> ANG0 0.0)
   (progn
    (setq X (* R (RFL:TAN (/ ANG0 2.0))))
    (setq X1 (* R (RFL:SPIRALFXR ANG1)))
    (setq Y1 (* R (RFL:SPIRALFYR ANG1)))
    (setq X2 (* R (RFL:SPIRALFXR ANG2)))
    (setq Y2 (* R (RFL:SPIRALFYR ANG2)))
    (setq X0 (+ X1
                (* X (cos ANG1))
                (* X (cos (+ ANG1 ANG0)))
                (* X2 (cos ANG))
                (* Y2 (sin ANG))
             )
    )
    (setq Y0 (+ Y1
                (* X (sin ANG1))
                (* X (sin (+ ANG1 ANG0)))
                (* X2 (sin ANG))
                (* Y2 -1.0 (cos ANG))
             )
    )
    (setq X3 (/ Y0 (RFL:TAN ANG)))
    (setq PA (list (+ (car P1) (* (cos A1) (- D1 (- X0 X3))))
                   (+ (cadr P1) (* (sin A1) (- D1 (- X0 X3))))
             )
    )
    (setq PB (list (+ (car PA) (* (cos A1) X1) (* -1.0 DIR (sin A1) Y1))
                   (+ (cadr PA) (* (sin A1) X1) (* DIR (cos A1) Y1))
             )
    )
    (if (= 0.0 LS1)
     (setq PLTST1 PA)
     (setq PLTST1 (list (+ (car PA) (* (cos A1) (- X1 (/ Y1 (RFL:TAN ANG1)))))
                        (+ (cadr PA) (* (sin A1) (- X1 (/ Y1 (RFL:TAN ANG1)))))
                  )
     )
    )
    (setq PC (list (+ (car PB)
                      (* (cos A1) (+ (* (cos ANG1) X) (* (cos (+ ANG1 ANG0)) X)))
                      (* -1.0 DIR (sin A1) (+ (* (sin ANG1) X) (* (sin (+ ANG1 ANG0)) X)))
                   )
                   (+ (cadr PB)
                      (* (sin A1) (+ (* (cos ANG1) X) (* (cos (+ ANG1 ANG0)) X)))
                      (* DIR (cos A1) (+ (* (sin ANG1) X) (* (sin (+ ANG1 ANG0)) X)))
                   )
             )
    )
    (setq PD (list (+ (car PC) (* (cos A2) X2) (* DIR (sin A2) Y2))
                   (+ (cadr PC) (* (sin A2) X2) (* -1.0 DIR (cos A2) Y2))
             )
    )
    (if (= 0.0 LS2)
     (setq PLTST2 PD)
     (setq PLTST2 (list (- (car PD) (* (cos A2) (- X2 (/ Y2 (RFL:TAN ANG2)))))
                        (- (cadr PD) (* (sin A2) (- X2 (/ Y2 (RFL:TAN ANG2)))))
                  )
     )
    )
    (setq RFL:ALIGNLIST (list (list S P1 PA 0.0)))
    (setq S (+ S (distance P1 PA)))
    (if (/= LS1 0.0)
     (progn
      (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list (list S PA PB (list PA PLTST1 PB 0.0)
                                              )
                                        )
                      )
      )
      (setq S (+ S LS1))
     )
    )
    (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list (list S PB PC (* DIR (RFL:TAN (/ ANG0 4.0)))))))
    (setq S (+ S (* R ANG0)))
    (if (/= LS2 0.0)
     (progn
      (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list (list S PC PD (list PD PLTST2 PC 0.0)
                                              )
                                        )
                      )
      )
      (setq S (+ S LS2))
     )
    )
    (setq RFL:ALIGNLIST (append RFL:ALIGNLIST (list (list S PD P2 0.0))))
   )
  )
  RFL:ALIGNLIST
 )
 (command "._UNDO" "M")
 (setq RFL:ALIGNLIST nil)
 (if (setq ENT (car (entsel "\nFirst tangent : ")))
  (if (= (cdr (assoc 0 (setq ENTLIST (entget ENT)))) "LINE")
   (progn
    (setq P11 (cdr (assoc 10 ENTLIST)))
    (setq P12 (cdr (assoc 11 ENTLIST)))
    (if (setq ENT (car (entsel "\nSecond tangent : ")))
     (if (= (cdr (assoc 0 (setq ENTLIST (entget ENT)))) "LINE")
      (progn
       (setq P21 (cdr (assoc 10 ENTLIST)))
       (setq P22 (cdr (assoc 11 ENTLIST)))
       (if (setq P0 (inters P11 P12 P21 P22 nil))
        (progn
         (if (> (distance P11 P0) (distance P12 P0))
          (setq P1 P11)
          (setq P1 P12)
         )
         (if (> (distance P21 P0) (distance P22 P0))
          (setq P2 P21)
          (setq P2 P22)
         )
         (if (setq PLIST (RFL:GETPLIST (car (entsel "\nPolyline to fit : "))))
          (progn
           (if (< (distance (last PLIST) P1) (distance (car PLIST) P1))
            (setq PLIST (reverse PLIST))
           )
           (while (and (/= nil PLIST)
                       (> (RFL:ANGLE3P P0 P1 (car PLIST)) (/ pi 2.0))
                  )
            (setq PLIST (cdr PLIST))
           )
           (setq PLIST (reverse PLIST))
           (while (and (/= nil PLIST)
                       (> (RFL:ANGLE3P P0 P2 (car PLIST)) (/ pi 2.0))
                  )
            (setq PLIST (cdr PLIST))
           )
           (setq PLIST (reverse PLIST))
           (if PLIST
            (progn
             (if (setq TMP (getdist (strcat "\nMaximum spiral length (enter 0 for no spirals) <" (rtos RFL:BESTCORNERLSMAX) "> : ")))
              (setq RFL:BESTCORNERLSMAX TMP)
             )
             (if (= RFL:BESTCORNERLSMAX 0.0)
              (setq RFL:BESTCORNERLSMIN 0.0)
              (if (setq TMP (getdist (strcat "\nMinimum spiral length <" (rtos RFL:BESTCORNERLSMIN) "> : ")))
               (setq RFL:BESTCORNERLSMIN TMP)
              )
             )
             (if (setq TMP (getdist (strcat "\nRadius (start value) <" (rtos RFL:BESTCORNERR) "> : ")))
              (setq RFL:BESTCORNERR TMP)
             )
             (if (setq TMP (getdist (strcat "\nStart step size <" (rtos RFL:BESTCORNERSTEP) "> : ")))
              (setq RFL:BESTCORNERSTEP TMP)
             )
             (if (setq TMP (getdist (strcat "\nStop step size <" (rtos RFL:BESTCORNERSTEPMIN) "> : ")))
              (setq RFL:BESTCORNERSTEPMIN TMP)
             )
             (setq CONTINUEFLAG T
                   LS1 (if (= RFL:BESTCORNERLSMAX 0.0)
                        0.0
                        (/ RFL:BESTCORNERR 10.0)
                       )
                   LS2 (if (= RFL:BESTCORNERLSMAX 0.0)
                        0.0
                        (/ RFL:BESTCORNERR 10.0)
                       )
                   R RFL:BESTCORNERR
                   STEP RFL:BESTCORNERSTEP
                   STEPMIN RFL:BESTCORNERSTEPMIN
                   RFL:ALIGNLIST (MAKEALIGNLIST P1 P0 P2 LS1 R LS2)
                   SUME2MIN 1E99
             )
             (if (= nil RFL:ALIGNLIST)
              (princ "\n! No valid solution for start values !")
              (while CONTINUEFLAG
               (command "_.delay" 0)
               (setq SUME2PREV SUME2MIN)
               (princ (strcat "\nStep = " (rtos STEP) ", LS1 = " (rtos LS1) ", R = " (rtos R) ", LS2 = " (rtos LS2) ", Sum E^2 = " (rtos SUME2MIN 2 16)))
               (setq SUME21 (if (< (- LS1 STEP) RFL:BESTCORNERLSMIN)
                             1E99
                             (CALCSUME2 (setq AL1 (MAKEALIGNLIST P1 P0 P2 (- LS1 STEP) R LS2)) PLIST)
                            )
               )
               (setq SUME22 (if (or (= 0.0 RFL:BESTCORNERLSMAX)
                                    (> (+ LS1 STEP) RFL:BESTCORNERLSMIN)
                                )
                             1E99
                             (CALCSUME2 (setq AL2 (MAKEALIGNLIST P1 P0 P2 (+ LS1 STEP) R LS2)) PLIST)
                            )
               )
               (setq SUME23 (if (< (- R STEP) 0.0)
                             1E99
                             (CALCSUME2 (setq AL3 (MAKEALIGNLIST P1 P0 P2 LS1 (- R STEP) LS2)) PLIST)
                            )
               )
               (setq SUME24 (CALCSUME2 (setq AL4 (MAKEALIGNLIST P1 P0 P2 LS1 (+ R STEP) LS2)) PLIST))
               (setq SUME25 (if (< (- LS2 STEP) RFL:BESTCORNERLSMIN)
                             1E99
                             (CALCSUME2 (setq AL5 (MAKEALIGNLIST P1 P0 P2 LS1 R (- LS2 STEP))) PLIST)
                            )
               )
               (setq SUME26 (if (or (= 0.0 RFL:BESTCORNERLSMAX)
                                    (> (+ LS2 STEP) RFL:BESTCORNERLSMIN)
                                )
                             1E99
                             (CALCSUME2 (setq AL6 (MAKEALIGNLIST P1 P0 P2 LS1 R (+ LS2 STEP))) PLIST)
                            )
               )
               (setq SUME2MIN (min SUME2PREV SUME21 SUME22 SUME23 SUME24 SUME25 SUME26))
               (if (< STEP STEPMIN)
                (setq CONTINUEFLAG nil)
                (cond ((= SUME2MIN SUMEPREV)
                       (setq STEP (/ STEP 10.0))
                      )
                      ((= SUME2MIN SUME21)
                       (setq LS1 (- LS1 STEP)
                             RFL:ALIGNLIST AL1
                       )
                      )
                      ((= SUME2MIN SUME22)
                       (setq LS1 (+ LS1 STEP)
                             RFL:ALIGNLIST AL2
                       )
                      )
                      ((= SUME2MIN SUME23)
                       (setq R (- R STEP)
                             RFL:ALIGNLIST AL3
                       )
                      )
                      ((= SUME2MIN SUME24)
                       (setq R (+ R STEP))
                             RFL:ALIGNLIST AL4
                      )
                      ((= SUME2MIN SUME25)
                       (setq LS2 (- LS2 STEP)
                             RFL:ALIGNLIST AL5
                       )
                      )
                      ((= SUME2MIN SUME26)
                       (setq LS2 (+ LS2 STEP)
                             RFL:ALIGNLIST AL6
                       )
                      )
                      (T
                       (setq STEP (/ STEP 10.0))
                      )
                )
               )
              )
             )
            )
            (princ "\n! No adjacent points found !")
           )
          )
         )
        )
        (princ "\n! No point of intersection found ! ")
       )
      )
      (princ "\n! Not a line entity ! ")
     )
    )
   ) 
   (princ "\n! Not a line entity ! ")
  )
 )
 (princ (strcat "\nMaximum offset = " (rtos (CALCE (reverse (cdr (reverse (cdr RFL:ALIGNLIST)))) PLIST)) "\n"))
 nil
)